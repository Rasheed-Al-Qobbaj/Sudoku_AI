{% extends "base.html" %}

{% block content %}
<div class="text-center">
    <h1>Play Sudoku</h1>
    <p>A new puzzle has been generated for you. Good luck!</p>
</div>

<div class="sudoku-grid-container" data-solution="{{ solution }}">
    <table class="sudoku-grid">
        <tbody>
            {% for r in range(9) %}
            <tr>
                {% for c in range(9) %}
                <td>
                    <div class="pencil-notes">{% for i in range(1, 10) %}<div class="note-number" data-note="{{i}}"></div>{% endfor %}</div>
                    {% if puzzle[r][c] != 0 %}
                        <input class="sudoku-cell given-number" type="text" value="{{ puzzle[r][c] }}" readonly>
                    {% else %}
                        <input class="sudoku-cell" type="text">
                    {% endif %}
                </td>
                {% endfor %}
            </tr>
            {% endfor %}
        </tbody>
    </table>
</div>

<div class="text-center mt-3" id="controls">
    <div class="btn-group me-3" role="group">
        <button class="btn btn-secondary" id="pencil-btn" data-bs-toggle="tooltip" data-bs-placement="top" title="Toggle Pencil Mode (Hold Spacebar)">
            <i class="fas fa-pencil-alt"></i>
        </button>
        <button class="btn btn-info" id="robot-btn" title="Watch the AI solve this puzzle">
            <i class="fas fa-robot"></i>
        </button>
    </div>
    <div class="btn-group" role="group">
        <button class="btn btn-warning" id="reset-btn">Reset</button>
        <div class="btn-group" role="group">
            <button class="btn btn-success dropdown-toggle" type="button" data-bs-toggle="dropdown">
                Generate New Puzzle
            </button>
            <ul class="dropdown-menu">
                <li><a class="dropdown-item generate-btn" href="#" data-difficulty="easy">Easy</a></li>
                <li><a class="dropdown-item generate-btn" href="#" data-difficulty="medium">Medium</a></li>
                <li><a class="dropdown-item generate-btn" href="#" data-difficulty="hard">Hard</a></li>
            </ul>
        </div>
    </div>
</div>

<div id="success-message" class="alert alert-success mt-4 text-center" style="display: none;">
    <strong>Congratulations! You solved the puzzle!</strong>
</div>



<script>
document.addEventListener('DOMContentLoaded', () => {
    const gridContainer = document.querySelector('.sudoku-grid-container');
    const allCells = document.querySelectorAll('.sudoku-cell');
    const pencilBtn = document.getElementById('pencil-btn');
    const resetBtn = document.getElementById('reset-btn');
    const generateBtns = document.querySelectorAll('.generate-btn');
    const successMessage = document.getElementById('success-message');

    let isPencilMode = false;
    let solution = JSON.parse(gridContainer.dataset.solution.replace(/'/g, '"'));
    let incorrectCellTimeout = null;

    // --- Event Listeners ---
    pencilBtn.addEventListener('click', togglePencilMode);
    resetBtn.addEventListener('click', resetUserInputs);
    gridContainer.addEventListener('keydown', handleArrowKeys);
    gridContainer.addEventListener('input', handleCellInput);
    generateBtns.forEach(btn => btn.addEventListener('click', generateNewPuzzle));


    function handleCellInput(e) {
        const cell = e.target;
        let value = cell.value;
        const notesContainer = cell.parentElement.querySelector('.pencil-notes');

        // --- Step 1: Input Sanitization (The Gatekeeper) ---
        if (incorrectCellTimeout) {
            clearTimeout(incorrectCellTimeout);
            cell.classList.remove('incorrect-cell');
        }

        // Ensure the input is only the last character typed and is a valid digit (1-9)
        if (value.length > 1) value = value.slice(-1);
        if (!/^[1-9]$/.test(value)) {
            cell.value = ''; // Clear any invalid input (like '0' or 'a')
            return;
        }
        cell.value = value;

        // --- Step 2: Decide Action based on Mode ---
        if (isPencilMode) {
            cell.value = ''; // ALWAYS clear the main input in pencil mode
            const noteCell = notesContainer.querySelector(`[data-note="${value}"]`);
            noteCell.textContent = (noteCell.textContent === value) ? '' : value;
        } else {
            notesContainer.querySelectorAll('.note-number').forEach(n => n.textContent = '');

            const index = Array.from(allCells).indexOf(cell);
            const row = Math.floor(index / 9);
            const col = index % 9;
            const solutionValue = solution[row][col];

            if (parseInt(value) === solutionValue) {
                cell.classList.add('correct-user-input');
                cell.readOnly = true;
                checkIfPuzzleIsComplete();
            } else {
                cell.classList.add('incorrect-cell');
                incorrectCellTimeout = setTimeout(() => {
                    cell.value = '';
                    cell.classList.remove('incorrect-cell');
                    incorrectCellTimeout = null;
                }, 500);
            }
        }
    }

    function resetUserInputs() {
        allCells.forEach(cell => {
            if (!cell.classList.contains('given-number')) {
                cell.value = '';
                cell.readOnly = false;
                cell.classList.remove('correct-user-input');

                const notes = cell.parentElement.querySelector('.pencil-notes');
                notes.querySelectorAll('.note-number').forEach(n => n.textContent = '');
            }
        });
        successMessage.style.display = 'none';
        unlockBoard();
    }

    function updateBoard(puzzle, newSolution) {
        solution = newSolution;
        gridContainer.dataset.solution = JSON.stringify(newSolution);

        allCells.forEach((cell, index) => {
            const row = Math.floor(index / 9);
            const col = index % 9;
            const val = puzzle[row][col];

            cell.value = '';
            cell.classList.remove('given-number', 'correct-user-input');
            cell.readOnly = false;

            if (val !== 0) {
                cell.value = val;
                cell.classList.add('given-number');
                cell.readOnly = true;
            }
            const notes = cell.parentElement.querySelector('.pencil-notes');
            notes.querySelectorAll('.note-number').forEach(n => n.textContent = '');
        });
        successMessage.style.display = 'none';
        unlockBoard();
    }

    function togglePencilMode() { isPencilMode = !isPencilMode; pencilBtn.classList.toggle('active'); }
    function checkIfPuzzleIsComplete() {
        for (let i = 0; i < allCells.length; i++) {
            if (!allCells[i].value || allCells[i].classList.contains('incorrect-cell')) return;
        }
        successMessage.style.display = 'block';
        lockBoard();
    }
    function handleArrowKeys(e) {
        const activeCell = document.activeElement;
        if (!activeCell.classList.contains('sudoku-cell')) return;
        let index = Array.from(allCells).indexOf(activeCell);
        let row = Math.floor(index / 9); let col = index % 9;
        switch(e.key) {
            case 'ArrowUp':   if (row > 0) index -= 9; break;
            case 'ArrowDown': if (row < 8) index += 9; break;
            case 'ArrowLeft': if (col > 0) index -= 1; break;
            case 'ArrowRight':if (col < 8) index += 1; break;
            default: return;
        }
        e.preventDefault(); allCells[index].focus();
    }
    function lockBoard() { allCells.forEach(cell => cell.readOnly = true); }
    function unlockBoard() {
        allCells.forEach(cell => {
             if (!cell.classList.contains('given-number') && !cell.classList.contains('correct-user-input')) {
                cell.readOnly = false;
             }
        });
    }
});
</script>
{% endblock %}